# Token Rules for TS-1388 Parser

Данный документ описывает правила формирования и применения токенов при разборе строк заказа TS-1388.
Важно! Очередность поиска каждого токена не линейная! (Задается в Grammar.md)

Токены используются для:

- замены найденных параметров в WorkString;
- предотвращения повторного захвата тех же фрагментов;
- удобства отладки (легко увидеть, какие параметры уже выделены);
- унификации логики последующей обработки.

---

## 1. Формат токена

Общий формат:


#<номер>_<имя>%

где:

<номер> — индекс параметра (целое число, как правило от 1 до 20), совпадает с индексом в массивах ParamName/ParamValue/ParamStart/ParamEnd/ParamErrorCode;

<имя> — строковое имя параметра, соответствующее ParamName(i).

Примеры:

#1_TYPE%
#2_ISPOLN%
#3_MODEL%
#4_AES%
#5_EX%
#6_SENSOR%
#7_T_LOW%
#8_T_HIGH%
#9_DLINA%
#10_DIAMETR%
#11_SHTUCER%
#12_LKABEL%
#13_TYPEKABEL%
#14_CLASS%
#15_HEAD%
#16_PLUG%
#17_SCHEMA%
#18_GP%
#19_TU%
#20_EXTRA%
(точный список имён задаётся в модуле констант и в ParamName())
2. Жёсткие ограничения

Внутри токена не допускаются пробелы.

Неправильно:
#1_ TYPE%
# 1_TYPE %

Правильно:
#1_TYPE%

Символы # и % используются только в качестве ограничителей токена.

<имя> должно строго соответствовать ParamName(i):
если ParamName(6) = "SENSOR", токен должен иметь вид #6_SENSOR%.

3. Процесс замены фрагмента на токен
При успешном нахождении параметра с индексом i:
Записываются:
ParamStart(i) — позиция первого символа значения в WorkString (1-based),
ParamEnd(i) — позиция последнего символа значения.

Вычисляются части строки:
leftPart  = Mid$(WorkString, 1, ParamStart(i) - 1)
rightPart = Mid$(WorkString, ParamEnd(i) + 1)

Формируется токен:
newToken = "#" & CStr(i) & "_" & ParamName(i) & "%"

Выполняется замена:
WorkString = leftPart & newToken & rightPart

4. Очистка значения перед заменой
Перед формированием токена выполняется очистка ParamValue(i):
удаление лишних пробелов;
удаление /, если они относились к структуре, а не к содержимому;
удаление скобок;

После очистки:
ParamValue(i) хранит уже нормализованное значение параметра;
в WorkString вместо исходного фрагмента стоит токен.

5. Нумерация и соответствие массивам
Для каждого параметра i:
ParamName(i) — логическое имя (например, "MODEL"),
ParamValue(i) — найденное значение,
ParamStart(i) / ParamEnd(i) — исходные границы,
ParamErrorCode(i) — результат валидации.

Токен #i_ParamName(i)% является единственно допустимым вариантом токена для данного параметра.

6. Поведение при повторном нахождении параметра
Если функция парсинга обнаруживает, что:

параметр уже имеет токен в WorkString (т.е. WorkString в этой области содержит #i_ParamName(i)%), или ParamStart/ParamEnd/ParamValue уже заполнены,
то Считать повторное нахождение ошибкой и возвращать TOKEN_CONFLICT.

7. Использование токенов при финальной проверке
После выполнения всех функций P_XXX:

WorkString должен состоять из:

набора токенов #i_ParamName(i)%,
разделителей (/, -, пробелы, допустимые запятые),

Если в WorkString остаются подстроки, не соответствующие ни одному токену и не описанные в Grammar.md, парсер вернуть ошибку UNKNOWN_FRAGMENT.

8. Связь с ReplaceParam

Функция ReplaceParam(ByVal n As Integer) должна:

Проверить, что:
n в допустимом диапазоне (1..20),
ParamValue(n) <> "",
ParamStart(n) > 0,
ParamEnd(n) >= ParamStart(n),
ParamErrorCode(n) указывает на то, что параметр найден и требует замены (например, код ERR_FOUND_NOT_CLEANED или 0).
Выполнить очистку значения по ТЗ.
Сформировать токен #n_ParamName(n)%.
Заменить соответствующий фрагмент WorkString на токен.
В случае невыполнения замены установить ParamErrorCode(n) = ERR_FOUND_NOT_CLEANED (3) и вернуть этот код.

9. Отладка и логирование
Рекомендуется для каждого шага:
выводить в Debug.Print:
имя параметра,
исходный фрагмент,
очищенное значение,
токен,
WorkString до/после замены.
Это позволяет по логам однозначно понять:
в каком месте строки был найден параметр,
какое значение он получил,
правильно ли токены встали в WorkString.