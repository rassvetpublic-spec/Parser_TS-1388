# Grammar for TS-1388 Parser (Excel VBA 2016)
Версия: 2025-12-17 (сверено по ТЗ, bas и `примеры_строк.csv`)

Документ задаёт нормативную грамматику и правила разбора строк заказа типа **TC/ТС-1388** после нормализации.  
Ключевая особенность реализации: **без Split** — параметры ищутся по диапазонам и/или по сегментам между символами `/`, с фиксацией `ParamStart/ParamEnd` и последующей токенизацией `ReplaceParam()`.

---

## 0. Термины и структуры данных

Массивы (индексы 1..20):

- `InputString` — исходная строка (как есть).
- `WorkString` — нормализованная строка, в которой по мере нахождения параметры заменяются токенами.
- `ParamName(i)` — имя параметра.
- `ParamValue(i)` — найденное значение.
- `ParamStart(i), ParamEnd(i)` — позиции (1-based) найденного фрагмента в `WorkString`. `0`, если не найден.
- `ParamErrorCode(i)` — состояние параметра (см. ниже).

Требование: массивы 1..20 всегда заполнены; если параметр не найден — `ParamValue=""`, `Start/End=0`.

---

## 1. Коды состояния параметров (ParamErrorCode)

Нормативный минимум:

- **0** — OK: параметр найден, очищен и токенизирован (ReplaceParam выполнен).
- **255** — FOUND_NOT_CLEANED: параметр найден, `ParamStart/End` заданы, но ещё не заменён токеном.
- **127** — NOT_DEFINED: параметр обязателен, но не найден/невалиден (критическая ошибка).

Допускается расширение кодов (например, MALFORMED_VALUE), но эти три значения обязательны.

---

## 2. Нормализация строки (NormalizeGOST)

Вход: `InputString`. Выход: `WorkString`.

Шаги нормализации:

1) `Trim` по краям.  
2) Длинные тире заменить на дефис: `–` (8211) → `-`, `—` (8212) → `-`.  
3) Все «нестандартные пробелы» (включая `ChrW(160)`, табы и Unicode-пробелы) заменить на обычный пробел.  
4) Удалить пробелы вокруг `/`: `" /"→"/"`, `"/ "→"/"` (в цикле до исчезновения).  
5) Сжать множественные пробелы: `"  "→" "` (в цикле).  
6) Заменить визуально похожие русские буквы на латиницу (A,B,C,E,H,K,M,O,P,T,X и т.п.).  
7) Выполнить ГОСТ-транслитерацию остальных русских букв (Ж→ZH, Ц→TS, Ч→CH, Ш→SH, Щ→SHCH, Ю→IU, Я→IA и т.д.).  
8) Регистр: для унификации рекомендуется `UCase(WorkString)` (поиск допускается case-insensitive).  
9) Рекомендация: `№` нормализовать в `N` (для схемы).

Примечание: десятичный разделитель в значениях — запятая (`,`) как в исходных данных.

---

## 3. Общая структура строки и параметры 1..20

Логический порядок параметров (как поля изделия):

1  `TYPE`      — тип изделия (TC-1388)  
2  `ISPOLN`    — исполнение  
3  `MODEL`     — модель/конструктив  
4  `KL_AES`    — класс безопасности (АЭС)  
5  `EX`        — маркировка взрывозащиты или `-`  
6  `HCX`       — НСХ/датчик (например PT100)  
7  `T_LOW`     — нижняя температура  
8  `T_HIGH`    — верхняя температура  
9  `DLINA`     — длина или габарит (в т.ч. `190X9X2`)  
10 `DIAMETR`   — диаметр, либо переход `10--->9`, либо `-`  
11 `SHTUCER`   — штуцер в скобках (например `(M8X1)`), либо `-`  
12 `L_KAB`     — длина кабеля (число или `-`)  
13 `KABEL`     — тип кабеля  
14 `KLASS`     — класс точности `AA|A|B|C`  
15 `HEAD`      — головка: `-` или варианты из ТЗ (в т.ч. `AG-10` **или** `ADXD`)  
16 `PLUG`      — заглушка/вставка: `-` или код (например `MIT8`, `PLT164`)  
17 `CXEMA`     — схема `N1..N6`  
18 `GP`        — `GP` или `-`  
19 `TU`        — `-` или `TU ####-###-########-####`  
20 `H3`        — хвост строки после TU (например `UHL3.1`), либо `-`

### 3.1 Разделитель `/` и важное исключение из примеров
Обычно параметры разделены `/`.  
Но **встречается вариант**, когда `TYPE` и `ISPOLN` идут вместе **в одном сегменте до первого `/`**, например:  
`TC 1388 B V3/ 8-1/ ...`  
Это корректно:  
- `TYPE` ищется по началу строки,  
- `ISPOLN` извлекается из хвоста этого же сегмента после конца `TYPE`.

Запись вида `AG-10/ADXD` в ТЗ означает **варианты** для одного поля `HEAD`, а не наличие `/` внутри значения.  
В реальной строке заказа `/` — разделитель сегментов; в одном сегменте содержится ровно одно значение.

---

## 4. Токенизация (ReplaceParam) и формат токена

После нахождения параметра `i`:

- заполнены `ParamValue(i), ParamStart(i), ParamEnd(i)`
- `ParamErrorCode(i)=255`

`ReplaceParam(i)` обязан:

1) Очистить `ParamValue(i)` от служебных символов:
   - пробелы
   - `/`
   - `(` и `)`
   - `Trim`  
2) Заменить в `WorkString` участок `[ParamStart..ParamEnd]` на токен:
   - `#<i>_<CLEANED_VALUE>%`
3) Обновить `ParamEnd(i)` под длину токена.
4) Сдвинуть `ParamStart/End` всех параметров справа (у которых `Start>0`), учитывая изменение длины.
5) Установить `ParamErrorCode(i)=0`.

---

## 5. Стратегия поиска: по сегментам (норма)

Чтобы исключить ложные совпадения, параметры, идущие после температур, должны извлекаться **строго из своих сегментов** (между соседними `/`).

Рекомендуется иметь 2 базовые функции:

- `GetSegmentBounds(pos) -> (segStart, segEnd)` по позиции `pos` в `WorkString`:
  - `segStart = InStrRev(WorkString, "/", pos) + 1` (или 1 если нет `/` слева)
  - `segEnd   = InStr(pos, WorkString, "/") - 1` (или Len если нет `/` справа)

- `GetNextSegmentBounds(segEnd) -> (nextStart, nextEnd)`

Далее: `DLINA`, `DIAMETR`, `L_KAB`, `KABEL`, `KLASS`, `HEAD`, `PLUG`, `CXEMA`, `GP`, `TU`, `H3` читаются последовательно сегмент за сегментом.

---

## 6. Порядок разбора (Parser): нормативная последовательность

Нормативный порядок вызовов (соответствует требованию ТЗ “строгая последовательность”):

1) `HCX` (#6) — обязателен  
2) `TYPE` (#1)  
3) `ISPOLN` (#2)  
4) `EX` (#5)  
5) `KL_AES` (#4)  
6) `MODEL` (#3)  
7) `T_LOW/T_HIGH` (#7/#8)  
8) `CXEMA` (#17)  
9) `DLINA` (#9)  
10) `DIAMETR/SHTUCER` (#10/#11)  
11) `L_KAB` (#12)  
12) `KABEL` (#13)  
13) `KLASS` (#14)  
14) `HEAD` (#15)  
15) `PLUG` (#16)  
16) `GP` (#18)  
17) `TU` (#19)  
18) `H3` (#20)

При критической ошибке обязательного параметра — `STOP` (возврат кода, заполнение `ParamErrorCode`).

---

## 7. Форматы значений (RegExp маски и правила)

Ниже маски форматов (VBScript.RegExp). В реализации допускается поиск “самого длинного совпадения” в диапазоне.

### 7.1 TYPE (#1)
TYPE_MASK:
`^TC[\-\s]*1388`

Если TYPE не найден в начале строки — допускается вставка `TC-1388/` в начало `WorkString` и повторный поиск.

### 7.2 HCX (#6)
HCX ищется **по справочнику** (лист "1", диапазон `M12:M19`). Справочник хранится **латиницей**.  
Поиск: найти любое значение из списка в `WorkString` (case-insensitive).  
Если не найдено: `ParamErrorCode(6)=127`, STOP.

### 7.3 ISPOLN (#2)
ISPOLN ищется:
- либо в сегменте сразу после TYPE,
- либо (если TYPE и ISPOLN в одном сегменте) — после конца TYPE в этом же сегменте,
- и до сегмента HCX.

ISPOLN_MASK (жадное/самое длинное совпадение):
`-|(?:A\s*)?(?:(?:EXD?|EX)\s*)?(?:BC|B)?(?:\s*(?:V3|N3|F3|G2))?`

Покрывает варианты из примеров: `-`, `B V3`, `B F3`, `B G2`, `BC`, `EX`, `EXB`, `EXBC`, `EXB V3`, `EXB F3`, `EXB G2`, `AB V3`.

Если ISPOLN не найдено: STOP.

### 7.4 EX (#5)
Если ISPOLN содержит `EX` или `EXD` — EX обязателен и ищется в сегменте слева от HCX:

EX_LABEL_MASK:
`(0|1)\s*(EX\s*IA|EXD\s*DB)\s*II\s*([ABCАВС])\s*T[1-6]\s*G[AaBb]\s*X`

Если ISPOLN НЕ содержит `EX|EXD` — EX должен быть строго `-` (в своём сегменте).

### 7.5 KL_AES (#4)
Если ISPOLN содержит `A` — AES обязателен и ищется в сегменте слева от EX:

AES_MASK:
`(2|3|4)\s*(НУ|HU|HУ|H|Н)?`

Если `A` нет — AES должен быть строго `-` (в своём сегменте).

### 7.6 MODEL (#3)
MODEL — сегмент между ISPOLN и AES (или между ISPOLN и EX, если AES=`-`).

MODEL_MASK (валидация сегмента):
`^/?(\d+)(?:-(\d+))?/?(.+)?/?$`

### 7.7 Температуры T_LOW/T_HIGH (#7/#8)
Ищется после HCX, в своём сегменте диапазона температур:

TEMP_RANGE_MASK:
`([+\-]?\d+(?:,\d+)?)\D+([+\-]?\d+(?:,\d+)?)`

### 7.8 CXEMA (#17)
CXEMA_MASK:
`(?:№|N)([1-6])`

### 7.9 DLINA (#9)
DLINA — следующий сегмент после температур.

DLINA_MASK:
`\d+(?:,\d+)?(?:\s*[Xxх]\s*\d+(?:,\d+)?(?:\s*[Xxх]\s*\d+(?:,\d+)?)?)?`

### 7.10 DIAMETR (#10) и SHTUCER (#11)
Если DLINA содержит `X/Х` (габарит) — тогда:
- `DIAMETR="-"`
- `SHTUCER="-"`
и параметры считаются обработанными.

Иначе диаметр берётся из следующего сегмента (после DLINA):

DIAM_SHT_MASK:
`(-|\d+(?:,\d+)?(?:--+>+\d+(?:,\d+)?)?)(?:\s*\(\s*([A-Za-z0-9\-xXхХ]+)\s*\))?`

Покрывает: `5(M8X1)`, `10--->9`, `-`.

### 7.11 L_KAB (#12)
L_KAB — следующий сегмент после DIAM.

L_KAB_MASK:
`-|\d+(?:,\d+)?`

### 7.12 KABEL (#13)
KABEL — следующий сегмент после L_KAB.

KABEL_MASK:
`[A-Za-z0-9\-]+`

### 7.13 KLASS (#14)
KLASS_MASK:
`AA|A|B|C`

### 7.14 HEAD (#15)
HEAD — следующий сегмент после KLASS.

HEAD_MASK:
`-|AG-\d+|ADXD|[A-Za-z0-9\-]+`

**Важно:** `AG-10/ADXD` в ТЗ означает варианты **HEAD = AG-10 ИЛИ HEAD = ADXD**. В строке заказа `/` внутри значения не используется.

### 7.15 PLUG (#16)
PLUG — следующий сегмент после HEAD.

PLUG_MASK:
`-|[A-Za-z0-9\-]+`

### 7.16 GP (#18)
GP — сегмент после CXEMA (по своему месту в последовательности сегментов).

GP_MASK:
`-|GP`

### 7.17 TU (#19)
TU — следующий сегмент после GP.

TU_MASK:
`-|TU\s*\d{4}-\d{3}-\d{8}-\d{4}`

### 7.18 H3 (#20)
H3 — хвост после TU (последний сегмент).

H3_RULE:
- допускается `-` или код (например `UHL3.1` после нормализации),
- формально: любое значение (Trim) с последующей валидацией по месту.

---

## 8. Минимальные требования к регресс-тесту

Набор `примеры_строк.csv` должен проходить:
- NormalizeGOST → Parser
- обязательные параметры (HCX, ISPOLN, MODEL, TEMP, DLINA, DIAM, L_KAB, KABEL, KLASS, HEAD, PLUG, CXEMA, GP, TU) извлекаются из корректных сегментов
- DIAM допускает переход `10--->9`
- HEAD допускает `AG-<n>` и `ADXD` как варианты

---
