# TokenRules for TS-1388 Parser (Excel VBA 2016)
Версия: 2025-12-17 (согласовано с Grammar_TS-1388.md и ErrorCodes_TS-1388.md)

Этот документ фиксирует **нормативные правила токенизации**, извлечения сегментов и пересчёта позиций,
которые обеспечивают устойчивую работу парсера без Split.

---

## 1) Сегменты и разделитель `/`

### 1.1 Определение сегмента
**Сегмент** — подстрока между двумя соседними символами `/` либо между краем строки и ближайшим `/`.

Пример:
`A/B/C` содержит сегменты:
1) `A`
2) `B`
3) `C`

### 1.2 Правило использования `/`
- В реальных строках заказа `/` используется как **разделитель параметров**.
- Символ `/` **не допускается внутри значения** одного параметра.
- Записи вида `AG-10/ADXD` в документации означают **варианты**, а не символ `/` внутри значения.

Исключение (из примеров): `TYPE` и `ISPOLN` могут находиться в одном сегменте до первого `/`:
`TC 1388 B V3/ ...`

---

## 2) Контракты функций Find_* (поиск параметров)

Каждая функция `Find_<PARAM>()` (или аналог):

### 2.1 До успешного поиска
Если параметр не найден:
- `ParamValue(i) = ""`
- `ParamStart(i) = 0`
- `ParamEnd(i) = 0`
- `ParamErrorCode(i) = 127` (NOT_DEFINED)
- вызывающий код решает: STOP (если обязательный) или продолжить (если необязательный)

### 2.2 После успешного поиска
Если параметр найден:
- `ParamValue(i)` = исходное значение из `WorkString` (как найдено, без токена)
- `ParamStart(i), ParamEnd(i)` = точные позиции найденного фрагмента в `WorkString` (1-based, включительно)
- `ParamErrorCode(i) = 255` (FOUND_NOT_CLEANED)
- **не менять `WorkString`** внутри `Find_*` (только извлечение и координаты)

После этого обязан быть вызван `ReplaceParam(i)` (если параметр должен быть токенизирован).

---

## 3) Longest-Match правило для RegExp

Если поиск ведётся RegExp по диапазону (не по одному сегменту), то применяется правило:

- выбирается **самое длинное** совпадение,
- при равной длине — совпадение с **меньшей начальной позицией** (левее).

Это необходимо, чтобы:
- `EXBC` не превращалось в `EXB`,
- `B G2` не превращалось в `B` и т.п.

---

## 4) Извлечение сегмента по позиции

Рекомендуется (нормативно) использовать вычисление границ сегмента без Split:

### 4.1 GetSegmentBounds(pos)
Вход: `pos` — позиция (1..Len(WorkString)).  
Выход: `(segStart, segEnd)` — границы сегмента, где находится `pos`.

Норма:
- `segStart` = позиция после ближайшего `/` слева от `pos` (или 1, если `/` слева нет)
- `segEnd`   = позиция перед ближайшим `/` справа от `pos` (или Len, если `/` справа нет)

### 4.2 GetNextSegmentBounds(segEnd)
Вход: `segEnd` текущего сегмента.  
Выход: границы следующего сегмента справа.
Если справа нет `/` — следующего сегмента нет.

### 4.3 Нормативный приём “последовательного чтения”
Параметры после температур извлекаются сегмент за сегментом:
`DLINA -> DIAM/SHT -> L_KAB -> KABEL -> KLASS -> HEAD -> PLUG -> CXEMA -> GP -> TU -> H3`

Это предотвращает “ловлю” чисел или кодов из чужих мест строки.

---

## 5) Токенизация: ReplaceParam(i)

### 5.1 Формат токена
Токен параметра `i`:
`#<i>_<VALUE>%`

Где:
- `<i>` — индекс 1..20
- `<VALUE>` — **очищенное значение** (см. 5.2)

Пример:
`PT100` -> `#6_PT100%`

### 5.2 Очистка значения перед токеном
Перед формированием токена удалить:
- пробелы
- `/`
- `(` и `)`
Затем `Trim`.

Рекомендация: не удалять `-`, `,`, `>`, `X`, т.к. они несут смысл (например `10--->9`, `50,5`, `190X9X2`).

### 5.3 Замена в WorkString
ReplaceParam обязан заменить подстроку `WorkString[ParamStart..ParamEnd]` на токен полностью.

### 5.4 Пересчёт границ остальных параметров
После замены длина строки меняется. Требование:

Пусть:
- `oldLen = ParamEnd(i) - ParamStart(i) + 1`
- `newLen = Len(token)`
- `delta  = newLen - oldLen`

Для каждого параметра `k`, где `ParamStart(k) > 0` и `ParamStart(k) > ParamEnd(i)` (строго справа от заменённого участка):
- `ParamStart(k) = ParamStart(k) + delta`
- `ParamEnd(k)   = ParamEnd(k) + delta`

Параметры левее не трогаются. Параметры, пересекающиеся по диапазону с заменой, в норме не должны существовать
(это признак ошибки выделения диапазона).

### 5.5 Завершение
После успешной ReplaceParam:
- `ParamErrorCode(i) = 0`

---

## 6) Правило “-” (Literal dash) и сегментная проверка

Когда грамматика требует значение `-` (например EX для не-EX исполнения, AES для не-A исполнения):
- проверка должна делаться **строго в своём сегменте**,
- не допускается поиск `-` по большому диапазону (иначе можно “схватить” дефис из другого поля).

Норма: `FindLiteralDashInSegment(segStart, segEnd)`.

---

## 7) Специальные значения и допустимые символы в VALUE

### 7.1 DIAMETR переход
Допускается значение вида:
- `10--->9` (стрелка/переход)

В токене сохраняется как есть: `#10_10--->9%`.

### 7.2 Габарит в DLINA
Если `DLINA` содержит `X`/`Х` (после NormalizeGOST обычно `X`):
- `DIAMETR` и `SHTUCER` устанавливаются как `-` без поиска.

### 7.3 CXEMA
Схема хранится как `N1..N6` (после нормализации `№` → `N`).
Токен: `#17_N3%`.

---

## 8) Минимальные инварианты для регресса

После успешного Parser:
- все обязательные параметры имеют `ParamErrorCode(i)=0` и присутствуют как токены в `WorkString`
- токены не перекрываются и не ломают `/`-структуру
- `WorkString` остаётся пригодной для диагностики: видно какие участки были заменены на `#i_...%`

---
